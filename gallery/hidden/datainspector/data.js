data = [{"id":"001-1","data":"Here firstly remove the edges which are safe so that the remaining edges are only the risky edges. Then use the BFS for going to find the edge from the vertex u to v.<br>If there are no risky edge, then go to the safe edge and add the edge to there so that the edge is a possible way from u to v.<br>"},{"id":"001-2","data":"To por [%unclear%] the edge from u to v, we have to find distinct edge from vertex to vertex.<br>"},{"id":"002-1","data":"Start with vertex u and consider adjacency matrix. Note risk as one and safe as 0. While traversing the route consider the route with least sum.<br>"},{"id":"002-2","data":"Adjust the graph by making it into a tree like subroutine, like a binary search tree with repeated nodes and then follow the DFS algorithm.<br>"},{"id":"003-1","data":"Perform algorithm of DFS by adding source cautions. Always choose neighbor with safe edge until it is necessary to choose risky edge. While backtracking you can keep count of risky edges.<br>"},{"id":"003-2","data":"1) let the number of edges be n<br>2) assign/label all the edges which are safe with weight of 1.<br>3) assign/label all edges which are risky with a weight of a large number greater than n, say (9999)<br>4) Apply Dijkstra's algorithm of the weighted graph.<br>5) Speed it up using heaps.<br>6) Obtain path will be the safest.<br>"},{"id":"004-1","data":"Choose all possible safe path (edges which won't form any cycle). Dijkstra's algorithm.<br>"},{"id":"004-2","data":"Perform a DFS, choosing safe edges wherever possible, else choose the risky edge.<br>"},{"id":"005-1","data":"Assign cost to each edge and starting from the safe check for the lowest cost & traverse towards that node.<br> cost(u_1, e) > cost(u_2, e), then skip to next node.<br>Have a risk found visited array[] to have all the risk nodes identified, while traversing the array eliminate the nodes present in risk found visited array[] - shortest path p will be found, risky free can be down efficiently.<br>"},{"id":"005-2","data":"By using BFS & DFS we get the same amount of cost, but using dynamic programming you can get efficiency and running spanning tree.<br>"},{"id":"005-3","data":"we can start from u and keep on searching for v by avoiding risky edges, if there is no other way apart from risky then we can to that risky way like dynamic programming algorithm path. <br>[%unclear%]<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;isSearch nonrisky()<br>&nbsp;&nbsp;&nbsp;&nbsp;if (i==0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = risky;<br>&nbsp;&nbsp;&nbsp;&nbsp;else p2 nonrisky(a[i]);<br>}<br>"},{"id":"006-1","data":"To search in BFS pattern from leaf node to root node, so that all node would cover & go in less number of risky way.<br>"},{"id":"006-2","data":"We need to find the adjacent safe edges of the vertex u and then we keep on doing this to reach the v. We may use a count variable to count the risk edge. If that count is reached max that path is not taken. So after counting which path has least count that path selected.<br>"},{"id":"006-3","data":"Perform DFS for all safe edges starting form u.<br>"},{"id":"007-1","data":"Delete risk node on.<br>"},{"id":"007-2","data":"Use Kruskal's algorithm so that risky edges are eliminated.<br>"},{"id":"007-3","data":"Let us consider two pointers fast and slow. The fast pointer moves ahead and checks whether there are risky edges or not. If there is a risky edge only we can move slow pointers to next node.<br>fase = 2 nodes<br>slow = 1 node | vertice<br>"},{"id":"008-1","data":"Use spanning tree algorithm.<br>"},{"id":"008-2","data":"You can actually traverse all the paths, but it is Brute force.<br><br>So we can traverse from a point in the graph and find optimal subroutine with a d.p. [%unclear%]<br><br>Algo minimum risk() <br>{<br>// minimum risk count<br>// traverse along sub paths<br>// find and store the risk count using dynamic programming, find the minimum risk count path.<br>}<br>"},{"id":"008-3","data":"We can use shortest path algorithm to find by deleting all the risky edges.<br>"},{"id":"009-1","data":"Declaring a count variable and incrementing the count for every risky edge while performing BFS in a recursive way.<br>"},{"id":"009-2","data":"A graph G is given, we have to use BFS & DFS for the vertex v' subroutine is correct.<br>"},{"id":"009-3","data":"Algorithm: <br>&nbsp;&nbsp;&nbsp;&nbsp;Graph(u,v)<br>&nbsp;&nbsp;&nbsp;&nbsp;Find only edges path (v,u);<br>&nbsp;&nbsp;&nbsp;&nbsp;min[count ++];<br>[%unclear%]<br>"},{"id":"010-1","data":"(1) increment the value of i by 1 at every risky edge in every path.<br>(2) Give value 0 to the safe edge<br>(3) Then perform BFS<br>(4) Compare value of i and return least valued path.<br>"},{"id":"010-2","data":"We can apply prims Algorithm and which starts at vertex u so we can find the way from u to v but it may be lerpthy.[%unclear%]<br>"},{"id":"010-3","data":"First delete all safe edges from u to v. and then find the risky edges from starting vertex u to ending vertex v using techniques like BFS & DFS algorithm.<br>"},{"id":"011-1","data":"Efficient algorithm which for we can use is depth first search (DFS). Because in that it traverse not in the order of levels. It avoids the number of risky edges.<br>"},{"id":"011-2","data":"2. Perform shortest path algorithm from u to v.<br>3. For every t which is risky edge from u to v, remove all risky edges & try to find the shortest path from u to t, if there is non then include t.<br>"},{"id":"011-3","data":"E(r,s) V(u,v)<br>for (E(r,s),v(u,v))<br>{ <br>  for<br>"},{"id":"012-1","data":"BFS(a[1...n])<br>&nbsp;&nbsp;&nbsp;&nbsp;if n > 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check(a[1...n-1])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i=1 to n-1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if a[i] > a[n]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = a[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i] = a[n];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[n] = temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>"},{"id":"012-2","data":"Starting from node u, see for the risky edges not considering safe edges, (better remove safe edges). If cost are known, traveling sales person algorithm can be used to know the minimum cost to reach v from u using risky edges. If we cannot reach v using only risky edges, then consider safe edges too.<br>"},{"id":"012-3","data":"Start with DFS algorithm. If found an risky edge call DFS algorithm lowing risky edge. If v not found in level 1, then increament[%unclear%] DFS from the vertexes.<br><br>And the procedure repeated from the stasting.[%unclear%]<br>"},{"id":"013-1","data":"From the staring node follow DFS and traverse through safe nodes, if paths not achieved backtrack through other path where same process is continued. <br>"},{"id":"013-2","data":"Yes, we can first delete all the risky edges. But it will be incorrect. [%unclear%] good that we use DFS algorithm as it helps in backtracking and traverse with the risky edges.<br>"},{"id":"013-3","data":"Delete some risky nodes which will[%unclear%] producing cycles in the graph by calling the BFS.<br>"},{"id":"014-1","data":"Consider only the risky edges and then appy Prim's algorithm starting from vertex u.<br><br>or<br><br>Remove all safe edges and then apply Depth First Search algorithms as subroutine.<br>"},{"id":"014-2","data":"Perform Breadth-first search starting from vertex 'u' with considering only safe edges to traverse.<br><br>If there is no safe edge with any vertex, select least risky edge and traverse to next vertex.<br><br>Subroutine: BFS<br>"},{"id":"014-3","data":"We can use an algorithm of finding minimal spanning tree, either by Prim's algorithm or Kruskcal's algorithm to eliminate as many risky edges between u,v.<br>"},{"id":"015-1","data":"Start from vertex u, perform BFS on u.<br><br>Before going on to other node, delete all of the risky nodes attached to it.<br><br>If node v is found, return the path.<br>"},{"id":"015-2","data":"- Create minimum spanning tree considering risky edges as weight 2 and safe edges a weight 1. (use prims Algo) In prims consider 'u' vertex first.<br><br>- Traverse the tree and find the position of the vertex 'v'. Backtrack to u to find path.<br>"},{"id":"015-3","data":"Start from u and follow like DFS if there is a safety edge go to that vertex and search for next safety to reach v and so on. If there are no safety edge back track and choose another safety edge at the previous vertex. and follow the algorithm if there is no safety edge choose risky edge.<br><br>== 016<br><br>Start from vertex u, deleted all the risky edges and use depth first search algorithm and needed then add the risky edges until lead to v.<br>"},{"id":"015-4","data":"Graph(G,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i < n; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i== risky(a))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;safe (a);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>risky (int a) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (a==i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;<br>}<br><br>safe(int a) {<br>&nbsp;&nbsp;&nbsp;&nbsp;i ++;<br>&nbsp;&nbsp;&nbsp;&nbsp;return a;<br>}<br>"},{"id":"015-5","data":"Algorithm Optimal {<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;construct n*n matrix Type, where risk edge is 0 and safe edge 1, remaining 2;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;From node 'u' traverse till node 'v' by making use of \"visited\" array;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;calculate no. of risky edges i.e. if Type[i][i]==0;<br>&nbsp;&nbsp;&nbsp;&nbsp;select the minimum cost path;<br><br>}<br>"},{"id":"017-1","data":"Take weight of risky edge as 1 and safe edge as 0.<br><br>Construct a minimum spanning tree using Prim's algorithm. Use a breadth first search from u for v.<br>"},{"id":"017-2","data":"We will call multistage graph recursively, if we have a risky edge and safe edge we will ignore risky. If we have only risky edge we go through it.<br>"},{"id":"017-3","data":"Algorithm:<br>1) Start with the vertex u.<br>2) Search for the edges which are connected through u and the edge with the smallest-values among all the other edges consider that edge.<br>3) for(risky=1 risky < edges)<br>4) Delete all the risky edges and then perform a Breadth-frist search starting from vertex 'u' till we search vertex v.<br>5) End the searching strategy.<br>"},{"id":"018-1","data":"1) List done the risky edges<br>2) Start from u vertex, now BFS algorithm for all the vertices in the path, include the edge which is not present in risky edge list.<br>3) If for a vertex there is no other path than a risky edge, then backtrack to the previous vertex and choose another path.<br>4) If all the paths have risky edges then keep track of the number of risky edges by go to all the paths using the above steps.<br>5) The path with least number of risky edges is the optimal path.<br>"},{"id":"018-2","data":"Delete risky edges and use DFS. If DFS not possible follow BFS.<br>"},{"id":"018-3","data":"1. Start from the vertex u, if all the edges from u are risky take any path otherwise move through the safe edge and once you search s vertex again find the risky edges and try to avoid them.<br><br>2. Traveling safe person can be considered and all the risky edge are given a higher value and we can find the best possible route using backward and forward approach to solve the TSP.<br>"},{"id":"019-1","data":"Find the possible paths and the number of risky edges in each.<br><br>The best path would be the shortest and with less number of risky edges.<br>"},{"id":"019-2","data":"Call DFS for such graphs.<br>"},{"id":"019-3","data":"BFS, <br><br>node[i]=root<br>node[i]=min[adjac]<br>[%unclear%]<br>"},{"id":"020-1","data":"Shortest path algorithm (forward + backward) when we take risky edge as the metric.<br>"},{"id":"020-2","data":"Delete all risky edges and then perform DFS algorithm from vertex u. Dynamic programming.<br>"},{"id":"020-3","data":"Shortest path first (forward or backward) algorithm where we take metric as risky edge on net.<br>"},{"id":"021-1","data":"Delete all the risky edges and then perform Prim's algorithm.<br>"},{"id":"021-2","data":"Construct a minimum spanning tree avoiding most of the risky edges.<br><br>Perform BFS starting from node u.<br><br>As BFS always gives optimal path, it is used.<br>"},{"id":"021-3","data":"Shortest path first (forward or backward) algorithm where we take metric as risky edge or not.<br>"},{"id":"022-1","data":"Prims or Kruskals algorithm can be used to find the path from u to v, starting from vertex u. Every path from each vertex has to be checked for a safe edge in order to get the minimum number of risky edges.<br>"},{"id":"022-2","data":"Use Prim's algorithm and see that a path from safe edge is not chosen and only from risky edge is chosen.<br>"},{"id":"022-3","data":"Use shortest path first algorithm and choose a safe edge instead of shortest path in order to get an optimal solution.<br>"},{"id":"023-1","data":"Visit each vertex in the graph and if the vertex has any risky edges then if the other vertex on the end risky edge can be reached by any safe edge then remove that risky edge.<br><br>Initially store all the safe and risky edges in a matrix. After performing this we can remove all the unwanted risky edges. Then apply BFS to find the path between u and v.<br>"},{"id":"023-2","data":"Starting from vertex u move to vertex v in such a way that you get a spanning tree. In this spanning tree, if you want to move from one vertex to another and there are two routes of risky and safe edge, then opt for safe edge. A spanning tree for DFS algorithm with starting vertex at u is a selection for the given problem.<br>"},{"id":"023-3","data":"Delete all the safe edges like direct edges (u,v) & then apply find out the minimum cost spanning tree by using either Prim's algorithm or Kruskal's algorithm from u to v.<br>"},{"id":"024-1","data":"From vertex u, search for the safe edges and then perform DFS from that edge.<br><br>If there is no safe edge from u, also consider the edges of the children of vertex u and proceed through that edge which has safe edges.<br>"},{"id":"024-2","data":"1) Let G=(u,v) be a graph<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;2) Draw a spanning tree T, from graph G(u,v) using by avoiding risky edges or by using minimum risky edges.<br>&nbsp;&nbsp;&nbsp;&nbsp;3) Using the edges of Spanning tree T, traverse from u to v.<br>}<br>"},{"id":"024-3","data":"[%comment:explain by example]<br>"},{"id":"025-1","data":"1. Mark all the nodes<br>2. Find out all the risky edges, ignoring the safe edges.<br>3. Choose 2 edges u & v.<br><br>Then perform a DFS starting from vertex u.<br>"},{"id":"025-2","data":"First count=0, using DFS if it is a risk edge from increment count. Find all variables which has count less then return that root.<br>"},{"id":"025-3","data":"Delete all safe edges and then perform breadth first search starting from vertex u.<br>"},{"id":"026-1","data":"1. Initialize the count of the risk edges to 0.<br>2. During traversal from u to v, if the edge is marked as risky, increment the count. Using DFS algorithm.<br>3. Similarly find the other routes from u to v.<br>4. Return the route whose count value is less.<br>"},{"id":"026-2","data":"Consider the graph, stage wise<br>when source is given, go to <br>that stage from that stage to <br>the destination stage (i.e. that node) find the path.<br>Finally, backtrack from the destination node, such that<br>there are minimum number of risky nodes.<br>"},{"id":"026-3","data":"First find out all the possible ways from u to v using Prims algorithm. To all risky to safe edge give values as 1 and all safe to safe as 0. Now for all the way compare it and whichever way has the lowest value that's the best path for u to v.<br>"},{"id":"027-1","data":"Perform BFS starting from u, If the immediate node is v and edge is risky, backtrack and continue. If v is not reachable without risky edges, backtrack and include risky edge to search v.<br>"},{"id":"027-2","data":"Starting from u if you find a risky path. Choose an alternative from there which is not risky and continue till v using DFS.<br>"},{"id":"027-3","data":"Delete all the risk edges and construct a minimum spanning tree using Prims & Kruskal's . If there are any unconnected edges, then add the risk edge to make it a spanning tree.<br>"},{"id":"028-1","data":"Select the vertex u and construct the spanning tree having a path from u to v. Select the spanning tree from all the spanning tree in a such way that the number of risky edges should be minimum.<br>"},{"id":"028-2","data":"DFS as subroutine and avoid the risk edges.<br>"},{"id":"028-3","data":"It should choose any one of the vertexes and start traversing. If it finds a risky edge it should search for a safe edge. If a safe edge it not present at that particular vertex then it should carry on with the risky edge itself and repeat the process.<br>"},{"id":"029-1","data":"Perform BFS starting from u to v after deleting all safe edges. <br>It can also be done by minimum spanning tree.<br>"},{"id":"029-2","data":"Starting form vertex u to vertex v in such a way that we set spanning tree.<br>"},{"id":"029-3","data":"Check if there is a direct (u,v) edge or perform prim's algorithm with consideration of only risky edges (not weights here) which reaches v from u.<br>"},{"id":"030-1","data":"Start from the vertex u<br>// consider adjacency list/matrix for each vertex in the graph<br>for each element x in the adjacency list till u = v;<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if (u,v) = safe {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Choose this path<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u=x;<br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;else if (u,x)=risky // no safe path exists<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then u = x;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>// if two or more safe or risky edge exists from a particular vertex, take all possible ways and choose the one contains less risky edges.<br>"},{"id":"030-2","data":"first find all the paths from u to v which using backtracking method keeping count of all the risky nodes.<br>"},{"id":"030-3","data":"Algorithm Graph(u,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;Let (u,v) be a given edge {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (v,k) represent the next edge you want to visit.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((v,k) is risky) then {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((v,k+1)) // return true when next other edge exists, next other edge from 'v'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BF Graph(v,k+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graph(u, k+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BF Graph(u,k+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>"},{"id":"031-1","data":"Use the concept of Kruskal's algorithm but not actually that.<br>After entering to u, look for the newest 'safe' edge with minimum weight and again entering in to the safe look [%unclear%] for the 'safe' edge and continue this until you reach the vertex v.<br>"},{"id":"031-2","data":"We can use DFS algorithm. i.e. we can directly find the path from 'u' to 'v' and we can get less number of risky edges.<br>"},{"id":"031-3","data":"To find a path between the vertices u and v, we can use breadth first search by using only the minimum number of risky edges. As it consists of many ways we have to find out the minimum risky edges presented in that.<br>"},{"id":"032-1","data":"sort(a[v...c])<br>if n>1;<br>sort(risky > safe)<br>if (a[i] < a[i+1])<br>&nbsp;&nbsp;&nbsp;&nbsp;return type<br>[%unclear%]<br>"},{"id":"032-2","data":"firstly we initialize the U=risky and V=safe;<br>In node  we have 2 fields [data|link]<br>We have 'G' with vertex u and v to delete risky.<br>[%unclear%]<br>"},{"id":"032-3","data":"Start from u vertex, goto next nearest safe edge, and from there next less weight and nearest safe edge, found the path.<br><br>If for safe edge all paths are risky edge then goto next risky edge, go to next safe edge from there.<br>"},{"id":"033-1","data":"Use a simple shortest path algorithm to find the path from u to v.<br>"},{"id":"033-2","data":"It may be complex to delete all the risky edges. Instead of BFS, we may go for DFS (Depth first search), or by constructing a minimum spanning tree.<br>"},{"id":"033-3","data":"Draw a graph by removing all the 'safe' edges. Now we will have the graph which contains only risky edges. Now by finding the minimum cost from the reverse order. i.e. from goal vertex i.e. from v to u, we can easily obtain minimal path.<br>"},{"id":"034-1","data":"Delete all edges and perform DFS on the graph.<br>"},{"id":"034-2","data":"Use the risky edges and move from one edge to another edge edge using the the breadth first search.<br>"},{"id":"034-3","data":"Traverse through risky edges using a DFS algorithm starting from the vertex 'u' until you reach destination.<br>"},{"id":"035-1","data":"By using the minimum shortest path at the starting vertex, maximum number of risky edges can be removed. So, we can find the efficient path from u to v by using minimum shortest path algorithm.<br>"},{"id":"035-2","data":"If we have two vertices in a graph G, we can find the path using efficient algorithms, which vertex is near to 'u' if it is 'v' then trace the path otherwise another algorithms to find the path.<br>"},{"id":"035-3","data":"By using the concept of Prim's Algorithm. We have to eliminate the risk nodes, which are prone to the deadlocks which reduces the efficiency of the algorithm.<br><br>We have to keep (or) choose the safe nodes in such a way that it has minimum cost (or) weight in a graph.<br><br>This helps in constructing the graph with the minimum spanning tree i.e. with min cost for the graph (or) tree. This reduces the time complexity and space complexity.<br>"},{"id":"036-1","data":"Graph G, vertices u, v and to choose the safe path from u to v. if u is the initial vertex, then choose the edges of the vertex. if vertex has edge safe then choose the safe edge.<br>"},{"id":"036-2","data":"Identify all the risky edges and traverse in depth first search and call depth first search as subroutine. Using depth first search, time complexity can also be reduced and delete risky edges and follow depth first search.<br>"},{"id":"036-3","data":"Risky edges have high or low weight. Identify the risky edges with low weight. Delete all those risky edges. Now follow Prim's algorithm. Prim's algorithm goes with low weight edges. Therefore, obtained spanning tree will have fewest number of risky edges.<br>"},{"id":"037-1","data":"Eliminate all the risky edges and then perform DFS as a sub-routine.<br>"},{"id":"037-2","data":"Assume the cost of all risky edges as 999 and all safe edges as 1. Using Floyd's algorithm we can find a path between u and v with fewest number of risky edges.<br>"},{"id":"037-3","data":"Using merge sort algorithm first we can sort every risky and safe edges all together separately then we can use depth first search algorithm to find the path from u to v with minimum number of risky edges in the path.<br>"},{"id":"038-1","data":"You should apply Dijkstra's Algorithm and with the help of this algorithm you can delete all the risky edges and you can find the path easily. Or the Prim's algorithm (used).<br>"},{"id":"038-2","data":"Use one risky edge for traversal through two nodes, performing the DFS might be suggested.<br>"},{"id":"038-3","data":"We can take Risky path as a long distance between two vertex. After ignoring all possible risky path. We can apply Prim's algorithm to find minimum cost.<br>"},{"id":"039-1","data":"Use Prim's algorithm to find the shortest Path. Select the edges which are safe. Use risky or safe edges as the basis for weights.<br>"},{"id":"039-2","data":"Use DFS algorithm.<br>"},{"id":"039-3","data":"Ignore the safe edges and start performing quick sort on the vertices starting from edge u.<br>"},{"id":"040-1","data":"If we want to choose a path of minimum number of risky edges, Dijkstra's algorithm will be the best method, as all the edges will be covered with shortest path.<br>"},{"id":"040-2","data":"SafeAlgo(Graph G) {<br>&nbsp;&nbsp;&nbsp;&nbsp;while(node searched != v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at each vertex i in G,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply BFS and select the child connected with safe edges if the number of child is more than 1.// starting from u.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (both edges are risky) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select the first one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>"},{"id":"040-3","data":"Use Prim's algorithm to find the shortest path.<br>"},{"id":"041-1","data":"We can go from vertex u to vertex v by using the fewest number of risky edges through BST.<br>"},{"id":"041-2","data":"f() {<br>&nbsp;&nbsp;&nbsp;&nbsp;G(V), G(E), risky, safe;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(G(V) > risky) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;risky = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0;<br>}<br>"},{"id":"041-3","data":"We can assume all the risky edges as less prior to the safe edges.<br><br>Perform greedy algorithm in which we give highest priority to safe edges.<br><br>Thus we can find a way from vertex u to v without traversing risky edges.<br>"},{"id":"042-1","data":"We will draw all spanning tree of the problem and will select the graph which has minimum risky edges.<br>"},{"id":"042-2","data":"1) Let these all n vertices of p1 risky edges and p2 safe edges.<br><br>2) For (i=1 to n)<br>&nbsp;&nbsp;&nbsp;&nbsp;for (j=1 to n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a[i][j] == risky)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i][j] = INF - 1;<br><br>3) Discover all paths from u to v and store them in different array.<br><br>4) Count the number of risky edges in each array and store them in different array.<br><br>5) find the min count of all and select the path.<br>"},{"id":"042-3","data":"We can move forward from u to v by incremented it by 1 edge. We are in the previous edge and collect the value of next edge if we get that edge is risky then we can not move on that way and take another path and call BFS.<br>"},{"id":"043-1","data":"Use DFS.<br>"},{"id":"043-2","data":"Delete all risky edges and then perform minimum spanning tree algorithm so that all vertices can be selected with no cycle.<br>"},{"id":"043-3","data":"In graph G are two way risky and safe if we choose safe way. It is easy to every one when we choose risky way then something different to us and then number is 2, 7, 8.  [%unclear%]<br>"},{"id":"044-1","data":"Perform DFS.<br>"},{"id":"044-2","data":"Use depth first search technique.<br>"},{"id":"044-3","data":"Put the weight on the risky edges and same with safe side but weight of risky side is greater then the weight of safe side and then use Prim's algorithm which rich you to u to v with less number of risky edges.<br>"},{"id":"045-1","data":"Initially we have to take a source from u, watching all the edges so that we may take shortest path we can use SSSP (single source shortest path). In order to solve this problem we may use brounch and bound by just ignoring the risky edges. The SSSP will let us know the shortest path from u to v as the graph is undirected it will be easy to check the weight of edges in any direction.<br>"},{"id":"045-2","data":"d[u] + G[u,v] < d[v]<br>d[v] <- d[u] + G[u,v]<br>"},{"id":"045-3","data":"Minimum Spanning Tree techniques can be used to find the path between u and v.<br>"},{"id":"046-1","data":"1. for i->u to v-1<br>2. if G(i, i+1) == risky<br>3. check G(i,i+2)<br>4. else i ++;<br>"},{"id":"046-2","data":"[%unclear%]<br>1) start from u.<br>2) choose the shortest path from u to v.<br>3) let we move from u to edge u, if the edge is risky choose another edge.<br>4) Grimultance only choose safe edges again and again.<br>5) If no safe edge is there then take reach<br>6) If end point is v stop process.<br>"},{"id":"046-3","data":"Whenever a risky edge occurs don't choose the way and try to find the way of a safe edge and follows the path using Dijkstra shortest path algorithm.<br>"},{"id":"047-1","data":"* Let us handle this problem using Prim's algorithm and find the free edges and vertex.<br> <br>* Then you can add the minimum spanning tree to the given problem.<br><br>* Otherwise it is not possible at all.<br>"},{"id":"047-2","data":"Perform DFS by creating state diagram avoiding risky edges.<br>"},{"id":"047-3","data":"We can delete all risky edges first, after that we obtain graph with just safe edges. Then we can simply apply the Kruskal's algorithm to find the way from u to v.<br>"},{"id":"048-1","data":"Step 1: perform both BFS and DFS (to find all possible paths from u to v).<br><br>Step 2: Select the path with least number of risky edges in it.<br><br>Step 3: If number of risky edges are same, then select one with least number of edges.<br>"},{"id":"048-2","data":"Delete all safe edges and then perform Dijkstra's algorithm starting from vertex u.<br>"},{"id":"048-3","data":"FRE(G,V) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (edge(u,v) && isRisky()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(V)s<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;if (isRisky() && edge(u,v,)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = count + 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addtoArray();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>"},{"id":"049-1","data":"#define risky  1 // give max cost<br>#define safe 0 // give min cost<br>Given graph<br>path(u,v):<br>/* either perform DFS to traverse with minimal cost or any other standard algorithm to traverse */<br><br>D(u,v);<br>// apply Dijstra's Bellman-Ford to find total cost. <br>"},{"id":"049-2","data":"Delete all risky edges and then start at v, perform Prim's Algorithm or Dijkstra Algorithm as subroutine to reach u.<br>"},{"id":"049-3","data":"Algorithm for risky and safe edge<br><br>-> Find a path from vertex u to vertex v using most efficient algorithm without a risky edge.<br><br>-> Else, find all the paths from u to v which has risky edges using efficient algorithm.<br><br>-> Then, select the path with least risky edges.<br><br>* we get the required path at step 1 or <br>* most efficient Algorithm like Dijkstra's algorithm<br>"},{"id":"050-1","data":"[%comment: a graph without explanation]<br>"},{"id":"050-2","data":"Yes, exactly the connect undirected graph has two edges, safe and risky. To get through safe we can follow up Prim's algorithm in this scenories[%unclear%]. It will find best path.<br>"},{"id":"050-3","data":"(u,v) in G, or G(u,v)<br>for all the unmarked/ not traversed edges:<br>&nbsp;&nbsp;&nbsp;&nbsp;using Dijkstra's Algorithm:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Single source shortest path)<br><br>"},{"id":"051-1","data":"We can use Prim's algorithm and the construction of minimum spanning tree helps us to find the path from u to v in the graph G with minimum number of risky edges.<br>"},{"id":"051-2","data":"Delete all risky edges and then perform depth first search starting from vertex u.<br>"},{"id":"051-3","data":"Delete risk edge and we can perform Dynamic Programming.<br>"},{"id":"052-1","data":"Delete all safe edges and perform depth first searching algorithm from u[1,...,n-1] and v[1,...,n-1].<br>"},{"id":"052-2","data":"We can find the minimum spanning tree for the given graph so that it uses only the safe edges by avoiding the cycles thus neglecting risky edges. We may use Prims or Kruskal's algorithm.<br>"},{"id":"052-3","data":"First connect the graph with the safe edges and the unconnected vertices are connected using least possible risky edges to form minimum spanning tree.<br>"},{"id":"053-1","data":"move u to n and then move n to v.<br>"},{"id":"053-2","data":"Delete all safe edges and then perform a depth first search starting from u.<br>"},{"id":"053-3","data":"Delete all risky edges and then perform a BFS starting from vertex u.<br>"},{"id":"054-1","data":"Algorithm BFS<br>// Finding a path from u to v with fewest risky paths.<br>// Input: connected undirected graph<br>// Output: path with fewest risky paths<br><br>for i = 1 to n<br><br>delete all risky edges and perform BFS starting form u. Traverse through minimum weighted paths.<br>"},{"id":"054-2","data":"Delete all risky edges and perform a BFS starting from vertex u.<br>"},{"id":"054-3","data":"Prim's Algorithm is the best and an efficient algorithm to solve the problem.<br><br>Prims(G[u...v])<br>Because it omits cyclic path which is risky path and it has less number of edges.<br>"},{"id":"055-1","data":"By using shortest path first, we can find path from u to v.<br>"},{"id":"055-2","data":"Perform shortest path algorithm by taking source node as u.<br>"},{"id":"055-3","data":"[%comment: a graph]<br><br>u--v--a--b<br>"},{"id":"056-1","data":"Can use Kruskal's algorithm. It avoids cyclic formation.<br>"},{"id":"056-2","data":"Delete all the risky edges and connected with the vertices and perform the depth first search algorithm starting from the vertex 'u', it called the subroutine as \"DFS\" algorithm.<br>"},{"id":"056-3","data":"Short and job first.<br>"},{"id":"057-1","data":"Use Prim's algorithm to sort the edges with weights in increasing order. Find construct minimum spanning tree. Now find the path from u to v with safe edges.<br>"},{"id":"057-2","data":"Dijikstra's algorithm.<br>"},{"id":"057-3","data":"The graph G has both risky and safe edges to find the fewest umber of risky edges, we reduce the number of risky edges and apply DFS algorithm. From that we can easily find fewest number of risky edges.<br>"},{"id":"058-1","data":"Perform depth first search starting with the vertex u, by initially taking the greedy algorithm, construct the minimum spanning tree and span through the safety edges, by avoiding the risky edges.<br>"},{"id":"058-2","data":"We can use DFS as subroutine and delay the risky edges.<br>"},{"id":"058-3","data":"To follows the shortest path algorithm.<br>"},{"id":"059-1","data":"for (i=1; i<n; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;if(v[i] < u[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = <br><br>[%incomplete]<br>"},{"id":"059-2","data":"Starting from the minimum edge and apply Prim's algorithm to find the path from u to v. In Prim's algorithm, each vertices visit once.<br>"},{"id":"059-3","data":"Delete the safety edges from the graph and can use minimum spanning tree algorithm. Because the minimum spanning tree searches for the minimum numbers of edges drawn between the vertices.<br>"},{"id":"060-1","data":"Delete all risky edges and perform depth first search. Use the shortest path algorithm and greedy algorithm to find the shortest and minimum cost.<br>"},{"id":"060-2","data":"In this graph to skip the risky edge.<br>"},{"id":"061-1","data":"Perform the breadth first search and then delete the unwanted risky edges and in one place put the safe edge. The breadth first search can be performed by starting from vertex u.<br>"},{"id":"061-2","data":"The efficient algorithm to find a path from u to v is Prim's algorithm. We start from starting edge while searching the destination edge. We does not add from starting so I prefer Prim's algorithm is efficient one.<br>"},{"id":"061-3","data":"We can delete the safe edges by performing Depth-first search starting from vertex u. Because it will search each and every path starting from vertex, and backtracking is possible so it is easy to find minimum number of risky edges.<br>"},{"id":"062-1","data":"[%comment: unclear graph%]<br>"},{"id":"062-2","data":"By using Prim's algorithm, (i.e.) finding the minimum spanning tree for the given graph may solves this problem.<br>"},{"id":"062-3","data":"Start from safe edge and perform depth first search.<br>"},{"id":"063-1","data":"It includes the leaf node of the parent node.<br>[%unclear%]<br>"},{"id":"063-2","data":"Using Floyd's algorithm. Find the node (u,w) such that u in U (connected vertices) and w in U'.<br><br>Check whether it is risk or not.<br><br>If(risk) find alternate node else join by edge.<br><br>Through all connected nodes, find graph can be traversed.<br>"},{"id":"063-3","data":"Input: A weighted connected, undirected graph.<br>Output: minimum of G{V,E}, E->{0}<br>"},{"id":"064-1","data":"We can delete from bottom so that the tree is undisturbed and also u is the last tree left.<br>"},{"id":"064-2","data":"If we are using BFS algorithm, then the target node may be reached only if it is present in the nearest level. If the target node is present at the leaf, then it takes worst case time in find the target node.<br>"},{"id":"064-3","data":"We can use Prim's algorithm, and by constructing the minimum spanning tree, we can solve.<br><br>or<br><br>We can use traveling salesman algorithm to find the path. <br>"},{"id":"065-1","data":"Use Prim's algorithm.<br>"},{"id":"065-2","data":"Using Binary Search Tree, separate the risky and safe edge to the left and right side of G. Then delete all the risky edges using Depth First Search Algorithm from vertex u.<br>"},{"id":"065-3","data":"First we have to check the number of vertices in both risky and safe. Then we proceed the problem and find the solution.<br>"},{"id":"067-1","data":"Using the Prim's algorithm we can solve this problem, with the vertices u and v using risky and safe edges.<br>"},{"id":"067-2","data":"Using Prim's algorithm find the required number of edges in sorted order and then delete the risky edges and find the safe edge by constructing the minimum spanning tree.<br>"},{"id":"067-3","data":"Since the graph is undirected and connected we can use the Binary search tree and we and the weight can be easily balanced and all the nodes can be easily mentioned and weight can be mentioned. So it is easy to find a path from u to v.<br>"},{"id":"068-1","data":"Start from vertex u.<br><br>Perform depth first search to u.<br><br>Count the number of risky edges in each search.<br><br>Choose the path with minimum number of risky edges.<br>"},{"id":"068-2","data":"P(n) is T(nlogn); T(n) is T(1)<br>"},{"id":"068-3","data":"By using depth first search, we can separate risky and safe edges. Then by analysis of time, we can connect to get minimum spanning tree.<br>"},{"id":"069-1","data":"Perform a depth first search starting from vertex u and fill it with the safe edges as possible.<br>"},{"id":"069-2","data":"Delete all risky edges and perform depth-first search.<br>"},{"id":"069-3","data":"We can delete the safe edge, or without deleting the edge, using dynamic programming.<br>"},{"id":"070-1","data":"Depth first search.<br>"},{"id":"070-2","data":"Using the shortest path algorithm, we find a minimum path that is safe.<br>"},{"id":"070-3","data":"First we have to find out the risky and safe edges separately and then we have to compare the risky and safe edges to reach or visit all the vertices, edges u and v, and after that we have to compare all the risky edges connection. Store all the possible combinations in a graph or an array. After storing all the possible combinations sorting the values or else return the minimum value and it's path.<br>"},{"id":"071-1","data":"Prim's algorithm is a best efficient algorithm to solve this problem to dividing into subroutines.<br>"},{"id":"071-2","data":"We do this by minimum spanning tree by placing the weights to risky edges. So that we can travel through the minimum number of risky edges and safe edges will be reached from u to v.<br>"},{"id":"071-3","data":"It should have random edges.<br>"},{"id":"072-1","data":"Delete all the risky nodes and perform Depth first search.<br>"},{"id":"072-2","data":"G(u,v)<br>"},{"id":"072-3","data":"Delete the risky edges and perform DFS.<br>"},{"id":"073-1","data":"Using Hamilton circuit, construct a tree of all possible cases. It uses the dynamic programming to solve the problem. By constructing a Hamilton circuit, we get n number of solutions and through that we can get an accurate solution for this problem.<br>"},{"id":"073-2","data":"Remove one after one risky keys using DFS algorithm.<br>"},{"id":"073-3","data":"Delete risky edges from u to v and perform DFS.<br>"},{"id":"074-1","data":"We can use DFS traverse. That is \"DFS\" and delete all the nearest risky nodes but don't delete all the risky nodes. If we do DFS means, can easily find out the path from u to v.<br>"},{"id":"074-2","data":"For solve this algorithm we used to DFS algorithm.<br>"},{"id":"074-3","data":"Two edges in G, there are u and v. We can find the path between u and v. We can use Prim's algorithm. Prim's Algorithm used to find the shortest path between the starting and ending edges.<br>"},{"id":"075-1","data":"We can use Kruskal's algorithm which is easy to traverse the path from u to v with fewer edges. Krushkal's Algorithm is easy to design and traverse the path between the nodes.<br>"},{"id":"075-2","data":"[%unclear%]<br>"},{"id":"075-3","data":"DFS from vertex u.<br>"},{"id":"076-1","data":"Using in greedy technique DFS algorithm to solve it.<br>"},{"id":"076-2","data":"BFS algorithm, we can undirected graph G and the vertex set v, weight of the edge is E.<br>"},{"id":"076-3","data":"Delete all risky edges and then perform a DFS starting from u. Use divide and conquer technique to eliminate the risky edges.<br>"},{"id":"077-1","data":"Use only safe edges and then perform BFS algorithm.<br>"},{"id":"077-2","data":"Breadth first search is used to find the child by left and right of the parent node.<br>"},{"id":"077-3","data":"Perform Prims' algorithm starting from vertex u with minimum spanning tree to avoid risky edges.<br>"},{"id":"078-1","data":"Perform Prim's algorithm from the edge u to v (or) Kruskal's Algorithm.<br>"},{"id":"078-2","data":"Prim's Algorithm to visit all nodes with minimum cost kruskal's algorithm is also used.<br>"},{"id":"078-3","data":"[%comment: a graph%]<br>"},{"id":"079-1","data":"Remove all the safe edges and then perform a BFS starting from vertex u.<br>"},{"id":"079-2","data":"Delete all risky edges and perform a BFS.<br>"},{"id":"079-3","data":"The BFS algorithm does not applies instead of it. it takes DFS algorithm and delete all risky paths. Delete only the highest rate of risky paths.<br>"},{"id":"080-1","data":"[%comment: a graph%]<br>shortest path is 3<br>longest path is 18<br>"},{"id":"080-2","data":"[%comment: a graph%]<br><br>1-2-3-4<br>"},{"id":"080-3","data":"Delete all risky edges and then perform depth first search starting from vertex v.<br>"},{"id":"081-1","data":"Firstly, the graph starts with pointing to the initial vertex and then moves to find the next vertex with BFS with minimum spanning procedure to find the shortest path. Risky edge will be deleted first with different minimum spanning tree approach.<br>"},{"id":"081-2","data":"Skip the highest risky of the graph to reach the edge from breadth first searching.<br><br>[%comment: a graph%]<br>"},{"id":"082-1","data":"Perform Prim's algorithm and find the minimum spanning tree and find out the edges with the minimum number of risky edges.<br>"},{"id":"082-2","data":"We can use Prim's algorithm as it moves towards next nearest safe path. Here we don't care about weight so Kruskal or any other algorithm is not needed. Prim's algorithm can be implemented through greedy technique for best results.<br>"},{"id":"082-3","data":"Undirected graph G have two types of edges u and v. Draw a undirected graph using minimum spanning tree is a best for a undirected graph. Then draw the graph G(V,E).<br>"},{"id":"083-1","data":"By using the Prim's algorithm can find the path from the u vertices to v vertices can solve the problem using the algorithm.<br>"},{"id":"083-2","data":"for (i=0 to v[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;for (j=0 to v[j])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete r[i][j]<br><br>a[u] = 0;<br><br>for (i=0 to n) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (a[i] in G) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a[i]==v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[i]=a[v]<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>starting edge u end edge v. So first delete all risk edges, set u as first then add remaining edges to the v edge connecting.<br>"},{"id":"083-3","data":"Check whether u and v has direct path, we use Kruskal's algorithm which sorts safe edges first and [%unclear%] risky edges.<br>"},{"id":"084-1","data":"Depth first search algorithm.<br>"},{"id":"084-2","data":"[%comment: a graph%]<br>"},{"id":"084-3","data":"BFS<br>"},{"id":"085-1","data":"The efficient algorithm to solve this problem using dijsktra algorithm.<br>"},{"id":"085-2","data":"int *u,*v,*risk, *safe, G<br><br>value of u(reach) nodes<br>value of v(reach) nodes<br><br>risk = new (*u)<br>safe = new(*v)<br><br>G=risky<-safe<br>"},{"id":"085-3","data":"Clear the risky edges and do DFS to start from u to v. Check the edges are connected and with safe edges.<br>"},{"id":"086-1","data":"In this algorithm search the first vertex. A connected undirected graph u and v in G has first vertex.<br>"},{"id":"086-2","data":"The depth-first algorithm should be used to analyze the risky edges and then can find a path between u and v.<br>"},{"id":"086-3","data":"G -> {u,v};<br>if (u->v==R)<br>&nbsp;&nbsp;&nbsp;&nbsp;enter<br>&nbsp;&nbsp;&nbsp;&nbsp;get value(u-v,v)<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;u->v == s<br>"},{"id":"087-1","data":"If we want to find a path from u to v using the fewest number of risky edges we use Dijkstra's algorithm.<br>"},{"id":"087-2","data":"Using shortest path algorithm find the path from vertex u.<br>"},{"id":"087-3","data":"Floyd's algorithm is suitable for finding the path between u and v.<br>"},{"id":"088-1","data":"In an general algorithm, we may first delete all the risky path by the DFS algorithm and then find the safest path.<br>"},{"id":"088-2","data":"Breath-first search is easy way to find efficient algorithm from the vertex.<br>"},{"id":"088-3","data":"Delete all risky edges, by using the safe edges, perform the breadth first search form vertex v.<br>"},{"id":"089-1","data":"Backtracking algorithm can be used. If there is an risky edges are found we can trace back the graph and the solution can be found.<br><br>Ex: If there is an two distint vertices u and v in G, that you have find u to v without any risky edges. You just sort out the possibilities of the graph and go with all possibilities. If we used backtracking algorithm we are able to avoid unwanted risky edges.<br>"},{"id":"089-2","data":"Kruskal Algorithm can be used to find the direct edges. So that the risky edges can be avoided and we can find the shortest path algorithm.<br>"},{"id":"089-3","data":"Quick sort algorithm is efficient to solve the problem because it uses pointer in this sorting algorithm.<br>"},{"id":"090-1","data":"We can use Dijikstra algorithm to find the fewest number of risky edges.<br>"},{"id":"090-2","data":"First construct the spanning tree for the graph and go through it by depth first search by eliminating the risky edges in it.<br>"},{"id":"090-3","data":"At first make the two nodes with an risky and safe in the vertices graph G. The u to be safe and v is the risky edge, by using quick sort techniques can be solve the BFS algorithms.<br>"},{"id":"091-1","data":"Use Kruskal's algorithm to find the minimum spanning tree, so that all the paths get connected with minimum weighted edges.<br>"},{"id":"091-2","data":"Prim's and Kruskal algorithm can be adopted to find the path from u to v.<br><br>The number of risky edges will be few as we will look for a shortest path in every search of a path.<br>"},{"id":"091-3","data":"Use minimum spanning tree algorithm and give the risky edges with high weights and safe edges with less weights.<br>"},{"id":"092-1","data":"Find the risky edges. Solve those edges use Prim's algorithm to solve.<br>"},{"id":"092-2","data":"We can use Dijkstra's algorithm and find the path from u to v in all possible options.<br>"},{"id":"092-3","data":"In undirected graph the value of each node should be connected to all other nodes, and in a shortest distance of weight.<br>"},{"id":"093-1","data":"To find the path from u to v in undirected graph, use backtracking method, if risky edge arrived, then go back to the last visited node and track another path to reach the node v.<br>"},{"id":"093-2","data":"I choose the Prim's algorithm to solve this problem. Because we calculate the weight for each node, then we choose the less cost as the destination nodes. So Prim's algorithm is very easy to find the path of u to v.<br>"},{"id":"093-3","data":"Weight the risky edges with maximum weight and safe edges with minimum weight, using minimum spanning tree and by Prim's algorithm we can get minimum number of risky edges.<br>"},{"id":"094-1","data":"Keep the risky edges. Find the shortest path between the nearest nodes by using the minimum spanning tree and find the path between u and v nodes.<br>"},{"id":"094-2","data":"Delete the risky edges and use minimum spanning tree by deleting the risky edges.<br>"},{"id":"094-3","data":"To find the path from u to v using the fewest number of risky edges we can use the shortest path algorithm and also backtracking algorithm will reduce the risky edge to reach the final edge.<br>"},{"id":"095-1","data":"We can perform shortest distance algorithm to find a path from u to v using fewest number of risky edges, which may reduces the number of risky edges.<br>"},{"id":"095-2","data":"To use Prim's algorithm to find a path from u to v. Using Kruskal's algorithm to find the path. These are in Greedy technique. First you starting from u as initial vertices and then finish the vas final vertices.<br>"},{"id":"095-3","data":"1) start the program<br>2) then vertices u and v. Find the path to the number to the graph.<br>3) Then risky edges to clean the problem is the breadth and first subroutines.<br>4) we have to standard to BFS algorithm<br>5) stop the program<br>"},{"id":"096-1","data":"start (a[1...n])<br>if(n>1)<br>del(u)<br>for i=0 to n-1<br>&nbsp;&nbsp;&nbsp;&nbsp;count = count + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a[i]>a[j])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>Delete all risky edges and perform BFS.<br>"},{"id":"096-2","data":"Firstly a connected undirected graph is constructed then the minimum distance is assigned. Then the shortest distance are found then the other longer distance are deleted. The remaining graph is maintained and hence it forms a efficient graph G which it will not waste the distance. The algorithm can be designed for this logic.<br>"},{"id":"096-3","data":"To find a path from u to v using fewest number of risky edges we can use shortest path i.e. distance vector algorithm to find the shortest path. Thus this algorithm travels only in a way which has only shortest weight so by choosing the shortest path, we can move from source to destination very easily.<br>"},{"id":"097-1","data":"This problem can be solved by traveling salesman as graph coloring to implement the problem. Further we can void the unnecessary and risky edges. Further it is the shortest way to find all edges and to reduce the risks and improve the efficiency of a problem.<br>"},{"id":"097-2","data":"Connect the safe vertices and if we get the risky vertices means, then delete these vertices and then connect the remaining nodes. <br>"},{"id":"097-3","data":"Remove all the risky edges and start processing from the starting vertex u.<br>"},{"id":"098-1","data":"This problem can be solved by Prim's Algorithm.<br>"},{"id":"098-2","data":"The undirected graph G, from reach vertices u to delete all risky edges to find safe edges by to find minimum spanning tree of using vertices to go safer place in easiest way by Prim's algorithm (or) dijistra's algorithm.<br>"},{"id":"098-3","data":"An algorithm u and v is an edges of the graph. The started point can be define in the point.<br>"},{"id":"099-1","data":"[%comment: unclear graph%]<br>"},{"id":"099-2","data":"Breadth_first(u[1...n],v[1...n])<br>&nbsp;&nbsp;&nbsp;&nbsp;if (u<=n || v<=n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i=0 to n-1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if u[i] > v[j]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (u[n], v[n])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete (u[n],v[n])<br>"},{"id":"099-3","data":"In the graph G the path from u to v can be found by using DFS algorithm. The risky edges can be get in number using this.<br>"},{"id":"102-1","data":"Delete all the unwanted risky edges and use the shortest path algorithm or Floyd's algorithm to find the shortest path between u and v.<br>"},{"id":"102-2","data":"The edges of the vertices which has risk can be named in the higher value than the other and can perform Traveling Salesman Problem which will look for the minimum weight between two vertices.<br>"},{"id":"102-3","data":"We can delete all the risky edges and then use Prim's algorithm so that we can find a path between u and v which minimum number of edges.<br>"},{"id":"103-1","data":"Binary search tree, because it will give only the safe state.<br>"},{"id":"103-2","data":"Delete all risky edges and then perform All-pair shortest path algorithm starting from u.<br>"},{"id":"103-3","data":"We should use Dijkstra's algorithm to find the fewest from u to v by deleting all risky edges.<br>"},{"id":"104-1","data":"By using Prim's algorithm we can find the safest path to reach from u to v. When the path is risky we can't move further - so first remove the risky path.<br>"},{"id":"104-2","data":"The algorithm can use the DFS algorithm to find the path. It can be efficient and more clear in obtaining the path from u to v using the fewest number of risky edges.<br>"},{"id":"104-3","data":"u <- i<br>v <- i+1<br>for (u=1;u<=i;u++)<br>&nbsp;&nbsp;&nbsp;&nbsp;u -> v<br><br>The shortest path between u and v may be found by finding the shortest distance between two edges.<br>"},{"id":"105-1","data":"By using minimum spanning tree, you can perform a path from u to v by crossing fewest number of risky edges, starting from vertex u.<br>"},{"id":"105-2","data":"Minimum spanning tree or some greedy algorithm can be used. It may eliminate risky edges. The most efficient algorithm would be the shortest path algorithm. The shortest path drives out risky edges.<br>"},{"id":"105-3","data":"Consider the undirected graph G(u,v)<br><br>Shortest path algorithm can be used here to find the fewest risky edges. Then the solution can be found.<br>"},{"id":"106-1","data":"Sub-graph algorithm.<br><br>By using sub-graph algorithm, split the graphs into sub-graphs to avoid the risky edges.<br>"},{"id":"106-2","data":"2 types: directed edges and undirected edges.<br><br>Two distinct vertex u, v and a.<br>"},{"id":"106-3","data":"An efficient algorithm to solve the above described problem is Dijkstra's Algorithm.<br><br>By using the Dijkstra's Algorithm we can form the pair for nodes. Finally, we have to form a pair table using the algorithm.<br><br>After that we have to identify the shortest path from u to v.<br>"},{"id":"107-1","data":"The efficient algorithm to describe this may be Kruskal's one among the standard algorithm. It gives most of the minimum time and distance the edge on vertices travel to reach its destination.<br>"},{"id":"107-2","data":"The two distinct vertices u and v in G, we need to find a path from u to v with fewer risky edges. By using BFS, after visiting all the nodes, the leaf node is being visited without any risky edges.<br>"},{"id":"107-3","data":"For this problem, we use the top down approach and then perform this Prim's algorithm to find the path with few risky edges. I hope this is the average case for this problem.<br>"},{"id":"108-1","data":"Find all this risky and safe edges given in the graph and call the Greedy algorithm to find the path. Construct the minimum spanning tree, so that the minimum distance path can be determined.<br>"},{"id":"108-2","data":"Dijkstra's algorithm, shortest path algorithm can be used.<br>"},{"id":"108-3","data":"Identify the risky nodes and reduce the redundant paths to as from risky nodes to other nodes. Thus the path contains minimum number of risky nodes.<br>"},{"id":"109-1","data":"Delete the risky edges and run for Minimum Spanning Tree algorithm.<br>"},{"id":"109-2","data":"Use Dijkstra's Algorithm to find the minimum spanning tree.<br>"},{"id":"109-3","data":"We go for Prim's Algorithm, it is used to find the shortest distance from source to destination vertex.<br><br>Dijkstra's is also used to find Minimum spanning tree also used to find the solution.<br><br>The best one is Minimal spanning tree algorithm.<br>"},{"id":"110-1","data":"Leave the risky edges and connect through the safe edges to reach v. Thus we can form a path from u to v without any risky edges in it. There may be many possibilities, but we can connect the safe edges which gives us the least path.<br>"},{"id":"110-2","data":"Sort(a[1...n])<br>if (A <= n)<br>&nbsp;&nbsp;&nbsp;&nbsp;sort(a[1...n])<br>&nbsp;&nbsp;&nbsp;&nbsp;for (i=1 to n-1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>else <br>&nbsp;&nbsp;&nbsp;&nbsp;return<br>"},{"id":"110-3","data":"First check whether vertex u and is is risky edge, otherwise delete risky edges and starting from u and follows DFS as a subroutine to find a path from u to v.<br><br>if (u!= risky && v!=risky) {<br>&nbsp;&nbsp;&nbsp;&nbsp;delete(risky)<br>&nbsp;&nbsp;&nbsp;&nbsp;DFS(u,v)<br>}<br><br>DFS(n,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (v==n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>&nbsp;&nbsp;&nbsp;&nbsp;n=n/2<br>}<br>"},{"id":"111-1","data":"Can draw a graph with the risky edges and safe edges by deleting it and drawing out a new BFS tree with weighted u,v,w.<br>"},{"id":"111-2","data":"Find out the appropriate path which is to perform the deleting operation and using BFS algorithm to find the vertex. (the fewest number of risky edges.)<br>"},{"id":"111-3","data":"Kruskal's Algorithm is suitable for this problem, first we try to minimize the risky edge and choose the safe edge. <br><br>So Kruskal's Algorithm works efficiently for this problem.<br>"},{"id":"112-1","data":"For this problem, we can use Dijkstra's Algorithm to find the path from u to v using fewest number of risky edges.<br>"},{"id":"112-2","data":"Deleting is not necessary, use Prim's algorithm and then BFS algorithm to find the path with fewest risky edges.<br>"},{"id":"112-3","data":"Risky edges can be skipped after two safe edge, which will reduce the number of risky edges and form the path from u to v.<br>"},{"id":"113-1","data":"When a BFS is taken for a search, we would like to cover all the vertices in a breadth wise manner. Before going for a next edge we would check whether the edges going out is risky or safe. Always prefer to choose safe.<br>"},{"id":"113-2","data":"Start the depth-first search method from the safe edges avoiding the risky edges. After finishing DFS in safe edges, calculate the path from the fewest number of risky edges.<br>"},{"id":"113-3","data":"maintain a separate array for the risky edges, perform BFS starting from vertex u, on encountering a risky edge, eliminate it, by backtracking find another vertex, in case there are not other possible vertex, then include the vertex which involves a risky edge.<br>"},{"id":"114-1","data":"Given: G(u,v)<br><br>To find: path from u to v using fewest number of risky edges.<br><br>Use the Prim's algorithm to find the shortest path and then construct the minimum spanning tree to avoid risky edges.<br>"},{"id":"114-2","data":"Call the BFS starting from u.<br><br>Call the shortest path algorithm with starting vertex 'u' and count the number of risky edges used in each path. Choose the path from u to v with least count.<br>"},{"id":"114-3","data":"The Dijkstra's Algorithm can be used to solve this efficiently. Since if the cost is mentioned there the risky edges can be avoided easily using this algorithm.<br>"},{"id":"115-1","data":"Delete all the risky edges and perform DFS from u.<br>"},{"id":"115-2","data":"Delete all risky edges and then perform a DFS algorithm. Starting from vertex u.<br>"},{"id":"115-3","data":"BFS search has a shows the number of possible ways to go to achieve the correct destination.<br>"},{"id":"116-1","data":"Let safe edges be shorter edges than risky edges and use Prim's Algorithm to find the minimum spanning tree of the graph. Then deduce path from the edges u and v, which may give a path with fewer risky edges.<br>"},{"id":"116-2","data":"Mask the value of risky edges as highest value and perform Traveling Salesperson Algorithm using Branch and Bound techniques.<br>"},{"id":"116-3","data":"Let's assume that 'risky edge' to be an edge with high cost and 'safe edge' be an edge with 'low cost'. Apply minimum spanning tree algorithm like Prim's or Kruskal's algorithm to remove a risky edge in a given directed graph and form a minimum spanning tree. Now apply single source shortest path algorithm to find a path between a vertices 'u' and 'v'. This path will have very few number of risky edges between u and v.<br>"},{"id":"117-1","data":"We can perform a DFS as subroutine, as when we find the risk edges just popping out and come to the [%unclear%] edge and selecting the other edge. This way we can select<br>"},{"id":"117-2","data":"Starting from vertex u, perform a BFS of all adjacent nodes to v. If it is a risky edge, don't include and continue the process till vertex v is reached.<br>"},{"id":"117-3","data":"Fill up all the safe edges first and fill the lest risky edges and perform DFS to delete more risky edges.<br>"},{"id":"118-1","data":"Let G be a graph with vertex u and v. It contains two edges risky and safe. Call the DFS algorithm after deleting all the risky edge.<br>"},{"id":"118-2","data":"In undirected graph, G(V,E) vertices and edges it has two distinct u,v are the risky edges. In that, we delete all the risky edges. Using BFS algorithm.<br>"},{"id":"118-3","data":"We can use Warshall's algorithm and transitive closure for defining path from u to v.<br>"},{"id":"119-1","data":"Delete all risky edges and perform depth first search from the vertex u.<br>"},{"id":"119-2","data":"Consider the path from u to v. Assume it is disconnected. For this assumption it follows. It becomes a separate vertices. Assume that is connected. The following assumption is true and hence it matches a shortest path with fewest number of edges.<br>"},{"id":"119-3","data":"* Find the highest cost edge value of any safe edges k.<br><br>* give all the cost edge value of the safe edges a negative sign before the actual value. (eg -by it by is the edge cost)<br><br>* Add the highest value k with every cost of safe edges.<br><br>* Now construct the minimum spanning tree using Prim's or Kruskal's Algorithm.<br><br>* We can find all the vertices connected by the fewest number of risky edges of a shortest path.<br><br>* To still be efficient instead of adding k in step 3. We can add a highest value without touching the limits of risky edge.<br>"},{"id":"120-1","data":"Answer: hence there is a path between u and v with risky. For this problem Kruskal's algorithm is the best.<br>"},{"id":"120-2","data":"Here, we have connected undirected graph G with two types of edges risky and safe. Construct a cost matrix from the grpah. By using Dijkstra's algorithm, we are able to find the shortest path from u to v. This process may corss some risky paths but the final path must be a safer one.<br>"},{"id":"121-1","data":"Find all the possible paths starting from vertex u to vertex u in the graph G by call breadth first search as subroutine and count the risky edges in each path. The fewer risky edges gives the path as result.<br>"},{"id":"121-2","data":"If we want to find the path between u and v, use dynamic programming algorithm to find the path. Multi-stage graph easily found the path which starts from the vertices u and ends with v of the approach.<br>"},{"id":"121-3","data":"An efficient algorithm to find the path from u to v with fewest number of risky edges is achieved by branch and bound method, along with Prim's algorithm to reduce the number of risky edges in it.<br>"},{"id":"122-1","data":"Use Prim's algorithm, we reduce the edges which forms cycle, in addition to that, exclude the maximum number of risky edges.<br>"},{"id":"122-2","data":"Cannot be determined.<br>"},{"id":"122-3","data":"Delete the more risky edges but not all and perform all pair shortest path algorithm starting from the source vertex as 'u'. It must have a little risky edge, because it makes the path interesting, and end with the end vertex as 'v'.<br>"},{"id":"123-1","data":"Delete all safe edges and perform a backtracking method on dynamic programming method starting from vertex u.<br>"},{"id":"123-2","data":"Delete all safe edges and then perform DFS starting from u.<br>"},{"id":"123-3","data":"From the vertex v, the risky edges performs as a subroutines for safe edges, when the vertex u has to perform the BFS as subroutine for vertex v.<br>"},{"id":"124-1","data":"We can perform multi-stage graph technique both forward or backward approach, by keeping u as the initial stage and v as final stage and vice versa.<br>"},{"id":"124-2","data":"Algorithm of greedy method.<br>"},{"id":"124-3","data":"Start from the vertex 'u',<br><br>if there is no safe edge adjacent to 'u'<br>&nbsp;&nbsp;&nbsp;&nbsp;perform a DFS starting from 'u'<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;connect a path through safe edge and delete the risky edges adjacent to it<br><br>"},{"id":"125-1","data":"Delete all safe edges, and use greedy algorithm to find a path between u and v.<br>"},{"id":"125-2","data":"Delete all risky edges from a vertex u and then perform DFS starting from vertex u.<br>"},{"id":"125-3","data":"Use spanning tree algorithm to perform minimum value from vertex u to v. So that risky is avoided.<br>"},{"id":"126-1","data":"The BFS algorithm is used to identify the corrected subroutine.<br>"},{"id":"126-2","data":"To say whether the algorithm we have written is more efficient if and only if the time and space complexity is considered. Don't consider the BFS as subroutine, using BFS we can get brief and clear answer.<br>"},{"id":"126-3","data":"if u < v + 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;risky = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;safe = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;for (u = 0; u < v; u ++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if risky --;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return u;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>"},{"id":"128-1","data":"Using Kruskal's algorithm, we can remove edges which forms cycles in graph. By using spanning tree, we can find a path from starting vertex u to v. Else we may also use DFS to find path from vertex u to v.<br>"},{"id":"128-2","data":"We can use forward backtracking algorithm to find the path from u to v using the fewest number of risky edges.<br>"},{"id":"128-3","data":"Perform Kruskal's algorithm on graph G. The risky edges i.e. (edges of high cost) would have been almost deleted.<br>"},{"id":"129-1","data":"Include the safe edges using Kruskal's algorithm and then use the risky edges for connecting the left-out vertices.<br>"},{"id":"129-2","data":"[%comment: a graph...%]<br>"},{"id":"129-3","data":"We use single source to single destination shortest path algorithm. Which will give the shortest path from u to v among the all edges of the graph. Or the traveling salesman problem can be used which will find the least risky and the shortest path.<br>"},{"id":"130-1","data":"To find the path form u and v vertices of a graph may be used as an algorithm, which is dynamic programming, because that algorithm concluded by stage by stage of an given graph, it is suitable to solve the problems. Then algorithm states that position info n-1 stages, forward or backward approach is efficient to find the path between u and v vertices.<br>"},{"id":"130-2","data":"The two distinct vertices of u and v in G. The us and v consists of one edges only.<br>"},{"id":"130-3","data":"We can use Dijkstra's algorithm to construct a graph deleting risky edges.<br>"},{"id":"131-1","data":"Dijkstra's algorithm can be used. We can delete the risky edges and path from u to v can be found out.<br>"},{"id":"131-2","data":"Traverse from the safe edge and perform the DFS by reversing the risky edges.<br>"},{"id":"131-3","data":"Prim's algorithm can be used to solve this problem. The Prim's algorithm involves the visiting of all edges in minimum cost.<br>"},{"id":"132-1","data":"We can be using Dynamic Programming. If the edge is risky, we can use this edge and find the path between u and v.<br>"},{"id":"132-2","data":"Run through all safe edges by performing a DFS starting from vertex u and proceed till vertex v.<br>"},{"id":"132-3","data":"The undirected graph u and v as fewest way to the subroutine and the risky edges as connected in the graph G. The edges of Graph G as make the fewest number of edges in the indirected graph.<br>"},{"id":"133-1","data":"Delete all the risky edges and then perform DFS starting from vertex u.<br>"},{"id":"133-2","data":"Delete all risky edges and then perform DFS starting from vertex v.<br>"},{"id":"133-3","data":"Here, to fin the risky edges and using to find the fewest number of minimum spanning tree is used, why because the edges are located easily by minimum.<br>"},{"id":"134-1","data":"Perform spanning tree algorithm, [%unclear%] to find the risky edges.<br>"},{"id":"134-2","data":"First arrange all the risky edges in ascending order in a separate array, starting from u, construct a path using Prim's algorithm and include the risky edges from the solved array only if all the other safe edges forms a cycle included. Repeat till v is reached.<br>"},{"id":"134-3","data":"Consider the risky edges and perform backtracking method (DFS) starting from edges u, thereby following the BFS calling as a subroutine or else undergo Kruskal's algorithm.<br>"},{"id":"135-1","data":"G Risky edges.<br><br>G = {u,v}<br>Risky and safe delete all risky with safe.<br>"},{"id":"135-2","data":"Remove all the risky edges and follow the DFS algorithm starting from the vertex u. So that we can find the path from u to v with fewer risky edges.<br>"},{"id":"135-3","data":"For that we can use the Huffman code algorithm. It give the fewest number of risky edges from u to v. So my final efficient algorithm is Huffman coding.<br>"},{"id":"136-1","data":"Dijkstra's algorithm (Single source shortest path algorithm)<br>"},{"id":"136-2","data":"Perform BFS from u and if encounter a risky edge, delete it and backtrack to the previous state and continue the BFS search.<br>"},{"id":"136-3","data":"Delete all risky edges and perform DFS from vertex v.<br>"},{"id":"137-1","data":"Delete the two risky edges and then perform a DFS starting from vertex 'u'.<br>"},{"id":"137-2","data":"Delete all the risky edges and perform a minimum spanning tree starting from u.<br>"},{"id":"137-3","data":"The efficient algorithms used for solving the problem is Prim's algorithm. It is used for find the path between u to v using the risky edges.<br>"},{"id":"138-1","data":"Remove the risky edges and traverse.<br>"},{"id":"138-2","data":"We can use minimum cost spanning tree to find the list of weight of all nodes. THen connect the edges with its minimum weight using adjacency matrix table. We would connect the edges with fewest risky nodes.<br>"},{"id":"138-3","data":"Perform a BFS starting form vertex u to vertex v in graph G.<br>"},{"id":"139-1","data":"Algorithm (G, V(u,v))<br>  || vertices u,v in G<br>Risky node R in G, Safe node S in G<br><br>We find a path from graph with less number of risky edges.<br><br>Do the partition of G.<br>Coloring risky nodes.<br>Identify which node has high degree, in degree, cer<br><br>Traverse the graph on safe nodes. <br>"},{"id":"139-2","data":"NO IDEA<br>"},{"id":"139-3","data":"Leave all risky edges and perform path using the Prim's algorithm. Form the graph from the node u.<br>"},{"id":"140-1","data":"Backtracking algorithm / Branch and Bound algorithm.<br><br>Branch and Bound algorithm search each and every node and its link and perform BFS search.<br>"},{"id":"140-2","data":"Delete all risky edges and may perform backtracking method and also divide and conquer method from vertex u.<br>"},{"id":"140-3","data":"[%comment: unclear graph%]<br>"},{"id":"141-1","data":"The \"shortest path\" algorithm was used to find the few number of edges between u and v. During the traversal, call BFS, to verify whether v vertex present in the same level.<br>"},{"id":"141-2","data":"We can use Dijkstra's algorithm and include the edges that are safe starting from vertex u.<br>"},{"id":"141-3","data":"Risky ways use BFS traversal in every found edges.<br>"},{"id":"142-1","data":"We can have a recursive function. This function first checks if the edge is risky or safe and goes ahead to reach the destination vertex v. Traverse the number of vertices and check for other paths by backtracking. Then select the path with least number of risky edges which is wanted using counter.<br>"},{"id":"142-2","data":"Delete all the safe edges and then perform DFS.<br>"},{"id":"142-3","data":"Find all the safe edges and call DFS <br>&nbsp;&nbsp;&nbsp;&nbsp;if edge then exit <br>&nbsp;&nbsp;&nbsp;&nbsp;else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check for risky edge or safe edge<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if edge then exit<br>"},{"id":"143-1","data":"Algorithm Undirected Graph<br>a[n] = n + 1<br>a[n+1] = n + 2<br>...<br>a[1] = a[n]<br><br>if (x > 0) <br>begin<br>&nbsp;&nbsp;&nbsp;&nbsp;x = x + 1<br>else <br>&nbsp;&nbsp;&nbsp;&nbsp;x = x - 1;<br>end<br>"},{"id":"143-2","data":"First, draw the spanning tree for the graph G. Identify the safe edges ignoring the risky edges, then by using DFS algorithm, trace the path from u to v.<br>"},{"id":"143-3","data":"Construct a tree from the given undirected graph, such that all the risky edges form the left subtree and all the safe edges form the right subtree.<br><br>The vertices are split into left and right subtrees in such a way. that the root vertex is a safe edge with max value.<br><br>THe left subtree is built in such a way that all risky vertices on the left form a binary tree.<br><br>All safe edges on the right subtree form a binary tree, with maximum value vertex as root of the tree.<br><br>Traverse from the root vertex using DFS along the right subtree.<br><br>If both u and v are safe vertices then path is found.<br><br>If not, backtrack and search the left subtree until u and v are found.<br><br>Note: Right subtree contains safe vertices and left contains risky vertices, I have quoted it wrong, saying in the opposite way.<br>"},{"id":"144-1","data":"Delete all safe edges and then perform a DFS starting from vertex 'u'.<br>"},{"id":"144-2","data":"Algorithm findpath(u,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;consider all the edges from v;<br>&nbsp;&nbsp;&nbsp;&nbsp;loop {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for all edges from u {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if edge has at least one safeedge<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then choose it;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else choose any risky edge;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;} repeat until vertex 'v' is reached<br>}<br>"},{"id":"144-3","data":"shortestpath(u,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;K = {set of risky edges};<br>&nbsp;&nbsp;&nbsp;&nbsp;L = {set of safe edges};<br>&nbsp;&nbsp;&nbsp;&nbsp;u: n;<br>&nbsp;&nbsp;&nbsp;&nbsp;v: n+1;<br>&nbsp;&nbsp;&nbsp;&nbsp;DFS(u,v);<br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>}<br>"},{"id":"145-1","data":"Perform BFS from vertex 'u' and identify the path with fewest number of risky edges from the vertex u to v. Using BFS algorithm.<br>"},{"id":"145-2","data":"A graph G(V,E) is considered, we have to choose the path which consists of edges with least weight correspondence.<br>"},{"id":"145-3","data":"Method 1:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Step 1: Consider the given graph.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Step 2: Start from the first vertex, check for the edges<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (the edge count == 2) then check for the risky and safe edges. If there is a safe edge among them then proceed with that.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Step 3: If there is only one edge from the vertex then pass through the edge.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Step 4: repeat step 3 for the other vertices.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Step 5: reach the vertex you wanted.<br><br>Method 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;Perform DFS and find out the count of the risky and safe edges. If the risky edges are more then minimize the traversal through those edges. If the safe edges are more then try visiting the risky edges less.<br>"},{"id":"146-1","data":"Using DFS traverse from root node leaving risky edges.<br>"},{"id":"146-2","data":"Start from vertex 'u', check for the risky edge; if found then perform DFS from that risky edge until we get the vertex 'v'. If there are more than one risky edges from 'u' then proceed with one of them and if we didn't reach 'v' then proceed with the next risky edge.<br>"},{"id":"146-3","data":"Delete all risky edges to perform all the algorithm.<br>"},{"id":"147-1","data":"Start from the vertex u for each u to v in the risky edge:<br>&nbsp;&nbsp;&nbsp;&nbsp;delete {skip all the risky edges}<br>&nbsp;&nbsp;&nbsp;&nbsp;iterate loop until true;<br>&nbsp;&nbsp;&nbsp;&nbsp;repeat;<br>"},{"id":"147-2","data":"Find out all the risky edges and safe edges and perform DFS starting from any vertex after deleting all risky edges.<br>"},{"id":"147-3","data":"Use only one risky edge, which will be the longest shortcut from path u and v; one risky edge is enough if it is in between connecting longest path between them and then perform DFS algorithm.<br>"},{"id":"148-1","data":"We should fist count the number of risky edges between u and v. First remove all the risky edges and see how many more edges are required to complete the path. Place the risky edge only when no other path is present or else place the safe edge in the path. This should be tried in both path (u,v) and path (v,u).<br>"},{"id":"148-2","data":"Delete all risky edges and then perform a Dynamic Programming Multistage graph starting from vertex u.<br>"},{"id":"148-3","data":"Delete all risky edges and perform DFS algorithm.<br>"},{"id":"149-1","data":"To solve the above problem using efficient algorithm. Divide and conquer algorithm can find risky element in a graph. Divide construct spanning tree, after dividing so that time complexity decreases. For any complex problem using divide and conquer strategy to get optimal solution.<br>"},{"id":"149-2","data":"Firstly we need to know the risky edges, then get the optimal solution from u to v using DFS algorithm to see if it covers minimum number of risky edges. Else we can use another path using DFS from u to v.<br>"},{"id":"149-3","data":"By tracking all the safe edges and imposing Kruskal's algorithm, we can find the path, it required we can use a very few number of risky edges.<br>"},{"id":"150-1","data":"while(t=adjacent(u)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if t is not risky edge<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add to path<br>&nbsp;&nbsp;&nbsp;&nbsp;if t is v <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add path and break;<br>&nbsp;&nbsp;&nbsp;&nbsp;return path;<br>}<br>"},{"id":"150-2","data":"Use BFS algorithm to find the next safe node. If no safe nodes found in adjacent nodes, go with one risky node which has safe node as adjacent till the destination node is encountered.<br>"},{"id":"150-3","data":"By using minimum cost spanning tree method or by any of the algorithms which gives minimum cost for the spanning tree like Prim's, Kruskal's algorithm.<br>"},{"id":"151-1","data":"Don't delete risk edges visit risk edges as 1 ones or not so start using the coloring of the graph to visit it. Use the coloring algorithm which contain two colors.<br>"},{"id":"151-2","data":"Delete risky edges at all levels except at first and last level. If we delete at first/last levels, we may lose path from u to v. So after deleting some risky edges, we will apply standard BFS as a subroutine to find the path from u to v.<br>"},{"id":"151-3","data":"Assign higher weights to all the risky edges and light weight to the safe edges. Now we can perform Prim's algorithm on it. So if safe and risky present, safe is opted. If only risky is present, then we get minimum one. So we can complete the graph with fewer number of edges.<br>"},{"id":"152-1","data":"Start at the vertex u check for the safe edge and go through that path in the mean while also consider the shortest path first algorithm as a subroutine so that we can go to v with minimum number of safe edges.<br>"},{"id":"152-2","data":"BFS or DFS could be used. Because DFS contains backtracking algorithm to reach with minimum cost.<br>"},{"id":"152-3","data":"Delete all risky edges and then do DFS from vertex U. DFS as subroutine.<br>"},{"id":"153-1","data":"Traverse from u to v with different paths, path with least number of risky edges will be efficiently found.<br>"},{"id":"153-2","data":"initial vertex = v<br>final vertex = u<br>traverse all vertices from v to u<br>traverse edges with less spanning cost.<br>traverse with forming cycles.<br>"},{"id":"153-3","data":"By using Prim's algorithm where you start from a selected vertex and find the minimum cost edge and include it new graph. Then find the neighbor of the next vertices until we find a graph with all vertices and edges.<br>"},{"id":"154-1","data":"DFS of only safe edges. Connect isolated vertices with risky edges of lowest value using DFS from dead ends. Check that no cycles are formed.<br>"},{"id":"154-2","data":"path(u,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;while(path(u,v)==found) <br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ispath(u,nextvertex);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nextvertex==risky)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return to u<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proceed i.e.//repeat above until you reach 'v'<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>"},{"id":"154-3","data":"Select all safe edges and then use DFS.<br>"},{"id":"155-1","data":"Mark the risky edges with infinite weigh. A call Dijkstra's algorithm and pick the shortest path.<br>"},{"id":"155-2","data":"for i <- l to n<br>d[i] = v[l][n]<br>visited[i] = 0;<br>for u <- v<br>if (visited[u] == 0) and d[v] != risky edge<br>&nbsp;&nbsp;&nbsp;&nbsp;add(); // add the edge to the graph<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;del(risky edge);<br>min(); // To check for fewer no. of risky edges<br>min = 99;<br>check if (for 1 to n) d[i] < min<br>"},{"id":"155-3","data":"safe path exists<br>risky path doesn't exists<br>write the adjacency matrix.<br>1 if path exists<br>0 if path doesn't exists<br>while(u!=v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (i=1 to n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=1 to n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a[i][j]==0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count ++;<br>}<br>return count<br>"},{"id":"156-1","data":"DFS from u to v. min <- infinity, minpath <- null<br><br>when v found, look through the DFS stack, count number of risky edges. If count == 0, the stack represents the solution. Else if count < min, min <- count, minpath <- stack.<br><br>return min and min path.<br>"},{"id":"156-2","data":"Perform Prim's or Kruskal's on graph to compute minimum spanning tree where weight of risky is higher than weight of safe. After computing minimum spanning tree perform a traversal to the required node by BFS [%unclear%].<br>"},{"id":"156-3","data":"// Path from vertex u to v<br>path(G[1...n],u,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;Let w be intermediate node<br>&nbsp;&nbsp;&nbsp;&nbsp;while (there is still an edge) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>"},{"id":"157-1","data":"Convert the given undirected graph to BFS.<br><br>With each node, associate the number of risky edges it has.<br><br>Starting form u and v simultaneously go up the hierarchy using least risky nodes.<br><br>As the parents coincide, we have least risky path from node u to v.<br>"},{"id":"157-2","data":"Assume that algorithm like Prim's Algorithm in that while connected graph. [%unclear%]<br>"},{"id":"157-3","data":"Take a subgraph G^R with only risky edges, find shortest path v to all the possible vertices. Sort the vertices from shortest to highest.<br><br>Take  a subgraph G^S with only safe edges. Find vertices paths to all possible vertices from u. Find the vertices with fall in both the array the take the one with lowest risky path.<br>"},{"id":"158-1","data":"To find the shortest path we can use Dijkstra's algorithm.<br><br>void dijkstra (int u, int v, int a[n][m]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int i,j;<br>&nbsp;&nbsp;&nbsp;&nbsp;for (i=1; i<=n; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j=1; j <= m; j ++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new a[u] = min(a[u], a[u][v] + a[u]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>"},{"id":"158-2","data":"Using Dynamic Programming, we can store number of risky edges between vertex u and other vertices, and keep updating it.<br>"},{"id":"158-3","data":"Perform topological sorting using source removed method making safe edge as source visit all the leaving safe edges then remove it, we will get a path from u to v another way is using DFS in topological sorting.<br>"},{"id":"159-1","data":"Perform a DFS from vertex u to v with a charge where the algorithm retain a count on the number of risky edges at each possible path and the one with the least can be chosen all the solution.<br>"},{"id":"159-2","data":"This problem can be solved using [%unclear%] concepts and graph based algorithms. Make two arrays as risky and safe from every vertex to every vertex. For given vertex u and v, check for the safe road, if not choosing the lesser risky road from u to v. [Using dijkstra's algo and linear search]<br>"},{"id":"159-3","data":"Assign a negative weight say -k, to the safe edge and a positive weight, say +k to a risky edge and use the single source shortest path algorithm starting at u and which can take negative weight and compute the path from u to v and keep a trace of number of risky edges. The sum of the algorithm with the least weight must be the path.<br>"},{"id":"160-1","data":"Input: A connected undirected graph G<br>Output: Path from u to v using minimum risky edges<br><br>Delete all the risky edges from the graph, starting from vertex u check if a path exists from u to v as follows:<br>Traverse from one vertex to another using safe edge. If able to reach vertex 'v', then we have found out a path using only safe edges, else if a safe path does not exist between two vertices and there existed a risky path, then insert back the risky path and continue traversing as stated, else if no path exists, return path not found.<br>"},{"id":"160-2","data":"int path_finder(int a[][]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int b[][]; int d[];<br>&nbsp;&nbsp;&nbsp;&nbsp;for i = 1 to m {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all the risky edges must be copied to matrix b based on certain condition (like minimum cost)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;check for the shortest path from u to v using Dijkstra or Prim's from matrix where risky edges are neglected based on the safety on b matex. If after deleting risk edges if there is no path, then a risky edge with minimum cost must be included from a s..[%unclear%] <br>}<br>"},{"id":"160-3","data":"Data: u and v are 2 distinct vertices in G<br><br>Algorithm: -<br>&nbsp;&nbsp;&nbsp;&nbsp;for (i <- 1 to n-1) do  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (u != n) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (u == v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u -> 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u -> v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u ++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>"},{"id":"161-1","data":"First perform BFS on start vertex. If there is an edge going to be risky, then mark it black and if not, then mark it blue.<br><br>Perform this BFS operation on neighbor of start vertex and on neighbors of neighbor of start vertex and so on.<br><br>Now traverse from start vertex u to go to vertex v in such way that we black vertex may fall in the way.<br>"},{"id":"161-2","data":"[%comment: deleted%]<br>"},{"id":"161-3","data":"Delete optimal number of risky edges and then ...<br>"},{"id":"162-1","data":"Search for first safe path from u and perform BFS if node ends somewhere perform backtrack to present node and then continue.<br>"},{"id":"162-2","data":"Use DFS as it covers lesser number of edges as compared to BFS. Check if edge is risky then find other possible ways.<br>"},{"id":"162-3","data":"Delete all risky edges and then perform a BFS starting from vertex u.<br>"},{"id":"163-1","data":"Construct spanning tree of G using Prim's algorithm with minimum risky edges, from u to v.<br>"},{"id":"163-2","data":"This problem can be solved using BFS or DFS. The major difference is that BFS use queue (or implemented with the heap of a queue) whereas DFS use stack (push and pop) operation are performed. These are the graph traversal technique having the time complexity O(v^3). In BFS we have to empty the queue while in DFS we have to check the element from the stack.<br>"},{"id":"163-3","data":"Perform Prim's algorithm, exclude some risky edges.<br>"},{"id":"165-1","data":"For such type of problems we can go for minimum spanning tree algorithm, which gives us a graph with minimum weight and avoid cycle. In such a way we can find a path from u to v using fewest number of risky edges.<br>"},{"id":"165-2","data":"G -> Risky and safe<br>vertices -> u and v<br><br>According to the question G graph as 2 edges risky and safe so, we use to safe way by using the directed graph and using the BFS algorithm and find the safe path to move the exact location of graph G.<br>"},{"id":"165-3","data":"Prim's Algorithm.<br>"},{"id":"166-1","data":"Delete some of the risky edges and perform a DFS starting from source node u.<br>"},{"id":"166-2","data":"We could delete all the risky edges and then perform Dijkstra's algorithm starting from vertex u to reach vertex v.<br>"},{"id":"166-3","data":"Prim's algorithm as it first arrange all the weights in increasing order and hence the risky ones' are automatically removed.<br>"},{"id":"167-1","data":"Delete the risky which have larger distance and perform DFS starting from vertex u.<br>"},{"id":"167-2","data":"Perform DFS from the vertex u. Delete few risky edges.<br>"},{"id":"167-3","data":"The problem can be solved by using DFS using less risky edges.<br>"},{"id":"168-1","data":"Graph(G,u,v)<br>Delete all the risky edges starting form u to v. Then moving forward to v take all the safe edges. Then perform DFS algorithm.<br>"},{"id":"168-2","data":"i <- a[safe]<br>for (j = u to v) <br>&nbsp;&nbsp;&nbsp;&nbsp;if (i = a[safe])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfs(j)<br>&nbsp;&nbsp;&nbsp;&nbsp;delete(j)<br>"},{"id":"168-3","data":"MST()<br>BFS()<br>There two functions calls would do.<br>"},{"id":"169-1","data":"First we check for shortest path for u and v.<br><br>And then perform BFS algorithm.<br>"},{"id":"169-2","data":"Apply Bellman-Ford starting from vertex u.<br>"},{"id":"169-3","data":"First check us there, every other smallest distance path to reach u to v and then perform DFS starting from vertex u.<br>"},{"id":"170-1","data":"Do a BFS. If there is a risky edge to v, then do a DFS. Count the number of risky edges, compare risky edges in both case and proceed.<br>"},{"id":"170-2","data":"Use Dijkstra's algorithm and start finding from vertex u.<br>"},{"id":"170-3","data":"A connected graph is not make any cyclic loop.<br><br>Approach should be BFS.<br>"},{"id":"171-1","data":"The algorithm to solve this problem is Single pair shortest path. In this we have to select the shortest path to find the path from u to v.<br>"},{"id":"171-2","data":"To find a path from u to v using the fewest number of risky edges. First, we have to delete all the risky edges and then apply the single pair shortest path algorithm to find the path from u to v with fewest number of risky edges in it.<br>"},{"id":"171-3","data":"BFS(a) { risky[], safe[]; }<br><br>Running BFS if edge is risky add it to risky[] and else to safe[] at the end apply Dijkstra's algorithm from u to v and take as less as risky edges as possible.<br>"},{"id":"172-1","data":"Perform Prim's algorithm.<br>"},{"id":"172-2","data":"Topologies search after deleting the maximum risky edges.<br>"},{"id":"172-3","data":"Find the shortest path by omitting all risky edges and fill the edges where the graph is disconnected.<br>"},{"id":"173-1","data":"By deleting all the risky edges and then perform MST (Minimum spanning tree) to solve the problem.<br>"},{"id":"173-2","data":"Edges risky and safe. Delete all risky edges. Use minimum spanning tree to find out path.<br>"},{"id":"173-3","data":"Allow the all safe edge and then perform a BFS starting from vertex u.<br>Delete all the risky edges and then perform a high-first search starting from vertex u.<br><br>The path of the u to v.<br>"},{"id":"174-1","data":"Start from u.<br>&nbsp;&nbsp;&nbsp;&nbsp;Go to safe vertex<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if no safe vertex found<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go to risky one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;until v is reached<br><br>Traveling Salesperson Problem.<br>"},{"id":"174-2","data":"For (i=0 to n-1)<br>&nbsp;&nbsp;&nbsp;&nbsp;check for all risky edges and store their locations in a separate array<br><br>Then:<br>&nbsp;&nbsp;&nbsp;&nbsp;Calculate the number of hops (i.e. locations where risky edges present) from u to v in G through any MSP algorithm and then implement the one with minimum hop distance i.e. with minimum risky edge count.<br>"},{"id":"174-3","data":"Delete all risky edges except for one and perform BFS starting from vertex u.<br>"},{"id":"175-1","data":"Using the single source shortest path algorithm for graph we can get the destination path but with avoiding the risky edges.<br>"},{"id":"175-2","data":"We use DFS algorithm to find all the paths from 'u' to 'v' and then we search for the smallest path to reach 'u' to 'w' with minimum number of risky edges.<br>"},{"id":"175-3","data":"Make a spanning tree of the graph(G), maybe a minimal spanning tree suing Kruskal's algorithm and then find the path from vertex 'u' to vertex 'v' using Dijkstra's algorithm.<br>"},{"id":"176-1","data":"Reduce or else to eliminate the risky edges as many as possible and adjust the graph using binary search tree.<br>"},{"id":"176-2","data":"Ans: -<br>&nbsp;&nbsp;&nbsp;&nbsp;Apply the Bellman-ford algorithm.<br>&nbsp;&nbsp;&nbsp;&nbsp;initialize a counter to count the number of risky edges used.<br>"},{"id":"176-3","data":"We can use B tree in which we can process from vertex u and incluing and excluding node or right and left respectively.<br>"},{"id":"177-1","data":"Adjust the graph to BFS (Binary search tree).<br>"},{"id":"177-2","data":"Delete all risky edges and then perform a BFS starting form vertex u.<br>"},{"id":"177-3","data":"Starting from 'u'. We move to adjacent vertices and delete the risky edges among the adjacent one and move to next adjacent. If any vertex has only one adjacent and it is through a risky edge, you can move but only for a minimum number of times in the whole to reach the destination.<br>"},{"id":"178-1","data":"1) Delete all safe edges.<br>2) Call BFS from u vertex.<br>3) Calculate the number of risky between u and v.<br>"},{"id":"178-2","data":"step 1: u be start vertex; count = 0;<br><br>step 2: let the number of risky edges in G be r_n and safe edges in G be S_n<br><br>step 3: Go to the next vertex, count = count + 1;<br><br>step 4: if it is a safe vertex; count ++<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if it is a risky vertex;<br><br>step 5: while counter < r_n/2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter = count ++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else exit;<br><br>stop<br>"},{"id":"178-3","data":"Draw minimum cost spanning tree and graph G using Prim's or traversals algorithm and find the distance between u and v.<br>"},{"id":"179-1","data":"From the starting point, using the adjacent matrix and adjacency UST. Avoiding risky edges, go from the vertex u to v and then follow DFS (which includes backtracking). This may avoid the risky edges and include more number of safe edges in the path from u to v in the graph.<br>"},{"id":"179-2","data":"Consider a graph G(V,E) -> this graph consists of some risky and safe edges.<br><br>In order to move from vertex A to vertex D with very few number of risky edges give some heuristic value to each edge and traverse through the least heuristic value edge first continue this, until the goal vertex is reached. This algorithm is called as \"Hueristic search algorithm\"<br>"},{"id":"179-3","data":"f (u,v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int flag = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;for n = all edges connected to v {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (E[u,x] == sfae)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(u,v); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;if (flag == 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x -> any edge connected to v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(u,v);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>"}];